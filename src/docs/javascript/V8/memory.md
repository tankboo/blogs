# V8的内存管理

先来看一个例子

```jsx
function foo (){
  let a = 1
  let b = a
  a = 2
  console.log(a) // 2
  console.log(b) // 1
        
  let c = { name: '张三' }
  let d = c
  c.name = '李四'
  console.log(c) // { name: '李四' }
  console.log(d) // { name: '李四' }
}

foo()
```

可以看出在我们修改不同数据类型的值后，结果有点不一样。这是因为不同数据类型在内存中存储的位置不一样，特点也不一样。

### **V8内存结构**

首先，让我们看下V8引擎内存结构长什么样：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3fd3e3c5-ac46-4900-86f9-1b9a5105def1/Untitled.png)

### 栈

是一种`先进后出`的结构，参考一下餐盘的取和放。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7cb28264-9f37-4277-ba27-e8fe4d4384fc/Untitled.png)

栈的特点：

- 存放`基本数据类型` ：`Number, String, Boolean, null, undefined, Symbol, BigInt`
- `引用类型`地址（指针：在堆内存中存放的地址）
- 由系统`自动分配`内存空间，`自动释放`，占固定大小的空间
- 所有方法中定义的变量存在栈中，方法执行结束，这个方法的内存栈也自动销毁
- `存储顺序是连续的`，所以在新增或删除数据是也只需要将指针移动到对应的位置，然后删除或修改数据，所以栈的`速度非常快`
    
    [Untitled](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b84fb53343044c1d9f0c6d1ab57ba715~tplv-k3u1fbpfcp-watermark.awebp)
    

### 堆

堆常用来动态内存分配，程序在堆中寻找数据需要使用指针。

它的特点:

- 效率不如栈，但是可以存储更多的数据
- 可存储大小不确定的数据，如运行时确定
- 存储在堆中的常见类型有：`全局变量`、`引用类型`和其他`复杂的数据结构`
- 动态分配内存空间，大小不定也不会自动释放
- 堆内存中的对象不会因为方法执行结束就销毁，因为有可能被另一个变量引用(参数传递等)
- 可能会引起内存泄漏等问题，所以有垃圾回收机制

### **为什么会有栈和堆之分**

通常与`垃圾回收机制`有关。每一个方法执行时都会建立自己的内存栈，然后将方法里的变量逐个放入这个内存栈中，随着方法执行结束，这个方法的内存栈也会自动销毁。

为了使程序运行时占用的内存最小，栈空间都不会设置太大，而堆空间则很大

每创建一个对象时，这个对象会被保存到堆中，以便反复复用，即使方法执行结束，也不会销毁这个对象，因为有可能被另一个变量(参数传递等)引用，直到对象没有任何引用时才会被系统的垃圾回收机制销

而且JS引擎**需要用栈来维护程序执行期间上下文的状态**，如果所有的数据都在栈里在，栈空间大了的话，会影响到上下文切换的效率，进而影响整个程序的执行效率

### 内存生命周期

- 内存分配：当我们声明变量，函数，对象的时候，系统会自动为它们分配内存
- 内存使用：即读写内存，也就是使用变量，函数，参数等
- 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存

局部变量(函数内部的变量)，当函数执行结束，没有其他引用(闭包)，该变量就会被回收。

全局变量的生命周期直到浏览器卸载页面才会结束，也就是说**全局变量不会被垃圾回收**

### 内存泄露

程序的运行需要内存，对于持续运行的服务进程，必须及时释放不再用到的内存，否则内存占用越来越大，轻则影响系统性能，严重的会导致进程崩溃

`内存泄露`就是由于`疏忽`或者`错误`，导致程序`不能及时释放那些不再使用的内存`，造成内存的`浪费`。

### 什么情况下会造成内存泄露

- 没有声明而`意外创建的全局变量`
- 被遗忘的定时器和回调函数，没有及时关闭定时器中的引用会一直留在内存中
- `闭包`
- DOM操作引用(比如引用了td却删了整个table,内存会保留整个table)

### 内存泄露如何避免

- 减少不必要的全局变量，比如使用严格模式避免创建意外的全局变量
- 减少生命周期较长的对象，避免过多的对象
- 使用完数据后，及时解除引用(闭包中的变量,DOM引用,定时器清除)
- 组织好逻辑，避免死循环造成浏览器卡顿，崩溃

